# Project 5: SM2的软件实现优化 

## 1.实验原理

### 1.1 SM2基础算法原理

SM2是中国国家密码管理局发布的椭圆曲线公钥密码算法标准，基于椭圆曲线密码学(ECC)。主要组成部分包括：

(1)  **椭圆曲线参数**：定义在有限域上的椭圆曲线方程 y² = x³ + ax + b

(2)  **密钥生成**：私钥是随机数d，公钥是d*G（G是基点）

(3)  **数字签名**：使用SM3哈希算法和特定签名方案

(4）**加密解密**：基于椭圆曲线的密钥交换和对称加密组合

### 1.2 签名算法误用场景分析

根据文档20250713-wen-sm2-public.pdf，SM2签名算法存在多种误用场景，可能导致私钥泄露：

#### 场景1：泄露k导致私钥泄露

SM2签名公式：
```
s = (1 + d)^-1 * (k - r*d) mod n
```

如果攻击者知道k，可以解方程得到私钥d：
```
d = (k - s) / (s + r) mod n
```

#### 场景2：重用k导致私钥泄露

如果同一用户对两个不同消息使用相同的k签名，攻击者可以通过解方程组恢复私钥：

```
s1(1 + d) = k - r1*d mod n
s2(1 + d) = k - r2*d mod n
```

解得：
```
d = (s2 - s1) / (s1 - s2 + r1 - r2) mod n
```

#### 场景3：不同用户使用相同k导致私钥泄露

如果两个不同用户使用相同的k签名，他们可以相互推导对方的私钥：

对于用户A：
```
dA = (k - sA) / (sA + rA) mod n
```

对于用户B：
```
dB = (k - sB) / (sB + rB) mod n
```

### 1.3 签名伪造原理

ECDSA/SM2签名算法在某些情况下可以被伪造，特别是在验证过程不严格的情况下。伪造签名的基本思路是：

1. 随机选择u和v
2. 计算R = u*G + v*Q
3. 计算r = x(R) mod n
4. 计算s = r/v mod n
5. 计算e = r*u/v mod n

这样伪造的(r,s)对于消息哈希e将是有效的签名。

## 2.实验过程

### 2.1 SM2基础实现与优化

在SM2.py中实现了SM2的基础功能，包括：
- 密钥生成
- 签名与验证
- 加密与解密

并实现了4种优化方案：
1. **预计算表**：预先计算2^i * G加速标量乘法
2. **窗口法**：使用4-bit窗口减少加法次数
3. **Montgomery阶梯**：防止时序攻击
4. **哈希算法优化**：支持多种哈希算法

### 2.2  签名误用POC验证

在SM2-poc.py中实现了三种签名误用场景的验证：

1. **泄露k恢复私钥**：通过已知k直接计算私钥
2. **重用k恢复私钥**：通过两个使用相同k的签名解方程
3. **共享k恢复私钥**：不同用户使用相同k相互推导私钥

### 2.3  签名伪造实现

在Satoshi-signature-forgery.py中使用极小参数椭圆曲线演示了ECDSA签名伪造过程，由于原参数较大，运行时间较长，因此选用小参数减少运行时间，大导演是目的，展示在验证不严格时如何构造有效的伪造签名。

## 3.实验结果

### 3.1 SM2实现优化效果

运行SM2.py得到优化对比结果：

![5-1](C:\Users\31858\Desktop\5-1.png)

- **密钥生成**：成功生成了有效的私钥和公钥对
- **签名验证**：
  - 生成的签名(r,s)格式正确
  - 验证结果为True，确认签名算法实现正确
- **加密解密**：
  - 原始消息"Hello, SM21"被正确加密并解密还原
  - 加解密功能完整实现

##### 标量乘法优化效果：

| 优化方法                  | 执行时间(秒) | 加速比(基准=1) | 分析说明                             |
| :------------------------ | :----------- | :------------- | :----------------------------------- |
| 原始实现                  | 2.2055       | 1.00x          | 基准值                               |
| 预计算表(Improved1)       | 0.6314       | 3.49x          | 效果最显著，通过空间换时间           |
| 窗口法(4-bit, Improved2)  | 1.8536       | 1.19x          | 优化效果有限                         |
| Montgomery阶梯(Improved3) | 2.9236       | 0.75x          | 比原始实现更慢，符合预期(安全换性能) |

##### **关键发现**：

- 预计算表带来近3.5倍的性能提升，最适合性能敏感场景
- Montgomery阶梯因安全考虑牺牲了约25%性能
- 4-bit窗口法优化效果有限

##### 哈希算法性能：

| 算法     | 执行时间(秒) | 相对性能 |
| :------- | :----------- | :------- |
| SHA256   | 0.0040       | 基准     |
| SHA3-256 | 0.0049       | 慢22.5%  |
| BLAKE2s  | 0.0061       | 慢52.5%  |

### 3.2  签名误用验证结果

运行SM2-poc.py得到签名误用验证结果：

![5-2](C:\Users\31858\Desktop\5-2.png)

所有签名误用场景均成功验证，能够恢复出原始私钥。

### 3. 3 签名伪造结果

运行Satoshi-signature-forgery.py得到签名伪造结果（因原参数较大，超出本机运算效能，因此改用小参数）：

![5-3](C:\Users\31858\Desktop\5-3.png)

演示了如何构造有效的伪造签名，与真实签名对比显示伪造签名可以通过验证。

## 4.实验总结

1. **SM2优化**：通过预计算表和窗口法能显著提高标量乘法速度，而Montgomery阶梯提供了更好的安全性。哈希算法选择也影响性能，BLAKE2s表现最佳。
2. **签名安全**：实验验证了SM2签名算法在k值处理不当时的多种安全隐患，包括k值泄露、重用和共享都会导致私钥泄露。实际应用中必须确保每次签名使用不可预测的唯一k值。
3. **签名验证**：签名验证过程必须严格检查所有参数，否则可能被伪造。RFC 6979提出的确定性k值生成是防止k值相关攻击的有效方案。

本实验完整实现了SM2基础算法，验证了PPT中提到的签名误用场景，并演示了签名伪造的可能性。

